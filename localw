#!/usr/bin/env bash
set -ex

TAGS=""
COMMAND=""
PYTHON_VENV="${PYTHON_VENV:-}"
BINARY_NAME="${BINARY_NAME:-}"
CONTAINER="${CONTAINER:-}"
SUDO_ACCESS="${SUDO_ACCESS:-}"
EXPORT_LOCATION="${EXPORT_LOCATION:-}"
EXTRA_OPTIONS="${EXTRA_OPTIONS:-}"
CONTAINER_MANAGER="${CONTAINER_MANAGER:-toolbox}"
print_help() {
    cat << EOF
Usage: $(basename $1) [OPTION ...] -b [FILE] -e [DIRECTORY]
Wraps a binary into a script so that it'll run with other arguments applied when in PATH

    -r, --rootfull - runs as root
    -p, --python-path - supplied path for python3
    -c, --container - adds wrapper for container managers accordingly
    -b, --bin - the binary that will be used
    -e, --export-location - the export location that will be used
    -o, --options - extra options passed to the binary
    -h, --help, --usage - shows this help
EOF
}
has() { command -v "$1" &> '/dev/null' ;}
add_tag() { TAGS="$* $TAGS" ;}
push_back() { COMMAND="$* $COMMAND" ;}
error() { printf "%s\n" "$*" >&2 ;}
blocking_error() { error "$*" ; exit 1 ;}
add_tag 'local-wrapper'

while :; do
    case "$1" in
        -r|--rootfull)
            SUDO="1"
            add_tag "root_access"
            shift
            ;;
        -p|--python-path)
            if [ -n "$2" ] ; then
                PYTHON_VENV="$2"
                add_tag "python_module"
                shift
                shift
            fi
            ;;
        -c|--container)
            if [ -n "$2" ] ; then
                CONTAINER="$2"
                add_tag "toolbox_container"
                shift
                shift
            fi
            ;;
        -b|--bin)
            if [ -n "$2" ] ; then
                BINARY_NAME="$2"
                shift
                shift
            fi
            ;;
        -e|--export)
            if [ -n "$2" ] ; then
                EXPORT_LOCATION="$2"
                shift
                shift
            fi
            ;;
        -o|--options)
            if [ -n "$2" ] ; then
                EXTRA_OPTIONS="$2"
                shift
                shift
            fi
            ;;
        -h|--help|--usage)
            print_help "$0"
            exit 0
            ;;
        -*)
            blocking_error "Unknown option $1"
            ;;
        *)
            break
            ;;
    esac
done

[ -z "$BINARY_NAME" ] && blocking_error "Binary name was not defined, specify it with \"-b\""
[ -z "$EXPORT_LOCATION" ] && blocking_error "Please specify an export location"
[ ! -d "$EXPORT_LOCATION" ] && blocking_error "The export location must be an existing directory"

COMMAND="$BINARY_NAME"
EXPORT_LOCATION="${EXPORT_LOCATION}/${BINARY_NAME##.*}"

if [ -n "$PYTHON_VENV" ] ; then
    if ! has "$PYTHON_VENV" ; then
        error "Python3 interpreter not found: $PYTHON_VENV"
    fi
    
    push_back "$PYTHON_VENV" '-m'
fi

if [ -n "$CONTAINER" ] ; then
    if ! has "${CONTAINER_BACKEND-/usr/bin/podman}" ; then
        error "Container backend could not be found: ${CONTAINER_BACKEND-podman}"
    elif ! "${CONTAINER_BACKEND:-/usr/bin/podman}" container exists "${CONTAINER}" ; then
        error "Container does not exist: ${CONTAINER}"
    fi

    local CONTAINER_MANAGER_BASE = "$(basename ${CONTAINER_MANAGER:-/usr/bin/toolbox})"

    if ! has "${CONTAINER_MANAGER_BASE}" ; then
        error "Toolbox binary not found in path"
    fi
    
    if [ "${CONTAINER_MANAGER_BASE}" = "toolbox" ] ; then
        push_back "${CONTAINER_MANAGER:-/usr/bin/toolbox}" run -c "${CONTAINER}" "--"
    elif [ "${CONTAINER_MANAGER_BASE}" = "distrobox" ] ; then
        push_back "${CONTAINER_MANAGER}" "enter" "${CONTAINER}" "--"
    elif [ "${CONTAINER_MANAGER_BASE}" = "apx" ] ; then
        push_back "${CONTAINER_MANAGER:-/usr/bin/apx}" run
    else
        blocking_error "Container manager program is not supported!"
    fi
fi

[ -n "$SUDO" ] && push_back "${SUDO_PROGRAM-sudo}"
[ -n "$EXTRA_OPTIONS" ] && COMMAND="$COMMAND $EXTRA_OPTIONS"

{ cat << EOF
#!/bin/sh
# $TAGS
${COMMAND} "\$@"
EOF } | tee "$EXPORT_LOCATION" && chmod +x "$EXPORT_LOCATION"
